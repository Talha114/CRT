INCLUDE CANDY.INC
.MODEL SMALL
.STACK 0100H
;.286

.DATA
	GAME_TITLE DB '!CRT!', 0
	PLAYER DB 5 DUP(0), 0
	LEN_NAME DW LENGTHOF PLAYER
	CTR DW 0

	TXT DB 'ENTER NAME: ', 0

	HOWTO1 DB "HOW TO PLAY", "$"
	HOWTO2 DB 'The game is played by swapping candies vertically or horizontally.', '$'
	HOWTO3 DB 'A set of 3 matching candies is a combo.', '$'
	HOWTO4 DB 'A combo crushes the set of candies and gives points.', '$'
	HOWTO5 DB 'Reach the point threshold in the given moves to complete the level.', '$'
	;to create sets of 3 or more matching candies. When matched, the candies will crush and shift the candies above them. Match more than 3 candies to create combos', 0
		
	ARRAY CANDY <1,1>,<4,4>,<3,3>,<2,2>,<5,5>,<3,3>,<5,5>,<4,4>,<2,2>,<2,2>,<4,4>,<4,4>,<3,3>,<1,1>,<4,4>,<5,5>,<4,4>,<1,1>,<6,0>,<2,2>,<5,5>,<3,3>,<4,4>,<2,2>,<3,3>,<4,4>,<3,3>,<1,1>,<2,2>,<1,1>,<2,2>,<4,4>,<2,2>,<1,1>,<5,5>,<5,5>,<5,5>,<1,1>,<2,2>,<2,2>,<1,1>,<3,3>,<3,3>,<5,5>,<5,5>,<1,1>,<1,1>,<2,2>;,<5,0>
	
	RAND_ARRAY1 DB	1, 1, 5, 1, 4, 4, 2, 1, 5, 2,
				1, 5, 3, 3, 1, 1, 5, 2, 1, 1,
				3, 3, 2, 6, 4, 1, 2, 5, 2, 5,
				1, 1, 4, 5, 3, 3, 4, 1, 5, 4
				  
	RAND_ARRAY2 DB	4, 2, 5, 2, 1, 4, 1, 5, 1, 1,
					5, 2, 2, 5, 3, 1, 2, 4, 3, 3,
					1, 5, 2, 2, 4, 6, 3, 3, 2, 1,
					2, 3, 3, 2, 4, 2, 3, 2, 5, 2
					
	RAND_ARRAY3 DB	4, 5, 5, 4, 1, 1, 4, 2, 2, 3,
					5, 3, 2, 4, 5, 6, 4, 1, 1, 3,
					2, 4, 4, 1, 4, 4, 1, 2, 5, 4,
					1, 2, 1, 2, 4, 4, 5, 1, 4, 5
					
	RAND_ARRAY4 DB 	2, 3, 2, 2, 1, 4, 2, 5, 4, 4,
					3, 1, 4, 1, 5, 1, 2, 1, 1, 2,
					3, 2, 2, 3, 1, 1, 2, 6, 2, 4,
					1, 2, 4, 3, 5, 5, 3, 5, 4, 3
					
	RAND_ARRAY5 DB 	5, 2, 3, 5, 1, 3, 3, 3, 3, 1,
					3, 5, 3, 3, 4, 2, 4, 4, 1, 5,
					3, 2, 1, 3, 4, 3, 2, 2, 5, 3,
					1, 4, 2, 2, 2, 5, 3, 2, 1, 1
					
	RAND_ARRAY6 DB  5, 1, 3, 2, 3, 5, 2, 4, 3, 4,
					3, 1, 1, 2, 4, 1, 3, 4, 2, 4,
					2, 3, 4, 4, 3, 4, 4, 1, 3, 3,
					2, 1, 4, 1, 3, 5, 3, 1, 4, 1
					
	RAND_ARRAY7 DB	2, 1, 1, 2, 1, 5, 3, 5, 2, 3,
					5, 1, 2, 1, 4, 3, 3, 2, 1, 4, 
					4, 5, 4, 4, 3, 2, 5, 3, 5, 2, 
					5, 4, 4, 4, 1, 4, 3, 1, 3, 2
					
	INDEX DW 0
	
	GRIDCOLOR DB 10
	SQUARE_COLOR DB 1
	RECTANGLE_COLOR DB 4
	TRIANGLE_COLOR DB 5
	DIAMOND_COLOR DB 6
	PENTAGON_COLOR DB 11
	
	X DW 0
	Y DW 0
	
	STR1 DB 'LEVEL: ', 0
	STR2 DB 'NAME: ', 0
	STR3 DB 'SCORE: ', 0
	
	LV1 DB 'LEVEL 1', 0
	LV2 DB 'LEVEL 2', 0
	LV3 DB 'LEVEL 3', 0
	
	CELL DB 'CELL 0,0', 0
	OUTOFBOUNDS DB 'OUT OF BOUNDS', 0
	
	TEMP DW 0
	S1 DW 0
	S2 DW 0
	
	T DW 0
	U DW 0
	D DW 0
	L DW 0
	R DW 0	
	
	LVL1_STR DB "Level 1: ", "$"
	LVL2_STR DB "Level 2: ", "$"
	LVL3_STR DB "Level 3: ", "$"
	HS_STR DB "Highest Score: ", "$"
	
	LVL1_PTS DW 0
	LVL1_PTS_STR DB 10 DUP("$")
	
	LVL2_PTS DW 0
	LVL2_PTS_STR DB 10 DUP("$")
	
	LVL3_PTS DW 0
	LVL3_PTS_STR DB 10 DUP("$")
	
	TOTAL_PTS DW 0
	TOTAL_PTS_STR DB 10 DUP("$") 
	
	HIGHSCORE DW 0
	HIGHSCORE_STR DB 10 DUP("$")
	
	CHAR DB 0 ;To hold one character when reading file
	COUNTER DB 0 ;Generic counter
	LEN DW 0 ;Length of number when casted to string. Is used inside TO_STRING proc.
	FILENAME DB "Scores.txt",0 ;Name of file that holds scores
	HANDLER DW 0 ;Variable to store handle of open file
	NEWLINE DB 10 ;To write newline to textfile
	
	MOVES_STR DB "OUT OF MOVES", "$"
	GAMEOVER_STR DB "GAME OVER", "$"
	
	VEL1 DB 0
	VEL2 DB 0
	VEL3 DB 0
	
.CODE
MOV AX, @DATA
MOV DS, AX
MOV AX, 0
MOV CX, 0

	;mov ax, 4
	;mov cx, 180 ; X-position
	;mov dx, 30 ; Y-position
	;int 33h
	
	CALL TITLESCREEN
	
	CALL CLICK
	CALL DELAY

	CALL HOWTOPLAY

	CALL CLICK
	CALL DELAY
		
	MOV VEL1, 1
	MOV VEL2, 0
	MOV VEL3, 0
	MOV DI, 0		
			
	CALL INIT
			
	CALL MAKEGRID	
			
	MOV SI, 0
	MOV BP, 0
	
	.WHILE BP < 5	;NUMBER OF TURNS
		CALL SSS
		.WHILE DI < 2
			CALL INPUT				
			CALL DELAY			
			
			MOV DX, TEMP
			MOV S1[SI], DX		
			
			INC DI
			ADD SI, 2
		.ENDW				
		
		CALL SWAP		
		CALL CHECKCOMBO
		
		;MOV CX, 3
		;M1:
		;	CALL REGRID			
		;	CALL CHECKALL							
		;LOOP M1
		;CALL CHECKALL	
		
		CALL REGRID	
		CALL FILL
		
		CALL CHECKALL	
		
		CALL REGRID	
		CALL FILL
		
		CALL MAKEGRID
		
		MOV SI, 0
		MOV DI, 0
		
		.IF LVL1_PTS > 30
			JMP LEVEL2			
		.ENDIF
		
		INC BP
	.ENDW
			
	LEVEL2:	
	MOV VEL1, 0
	MOV VEL2, 1
	MOV VEL3, 0
	
	CALL INIT
	CALL LVL2
	
	MOV AX, 0	
	MOV BX, 0	
	MOV CX, 0	
	MOV DX, 0	
	MOV DI, 0

	MOV SI, 0
	MOV BP, 0
	
	CALL MAKEGRID
	
	.WHILE BP < 3	;NUMBER OF TURNS
		CALL SSS2
		.WHILE DI < 2
			CALL INPUT				
			CALL DELAY			
			
			MOV DX, TEMP
			MOV S1[SI], DX		
			
			INC DI
			ADD SI, 2
		.ENDW				
		
		CALL SWAP		
		CALL CHECKCOMBO
		
		;MOV CX, 3
		;M1:
		;	CALL REGRID			
		;	CALL CHECKALL							
		;LOOP M1
		;CALL CHECKALL	
		
		CALL REGRID	
		CALL FILL		
		
		CALL CHECKALL	
		
		CALL REGRID	
		CALL FILL
		
		CALL LVL2
		CALL MAKEGRID
		
		MOV SI, 0
		MOV DI, 0
		
		.IF LVL2_PTS > 30
			JMP LEVEL3
		.ENDIF
		
		INC BP
	.ENDW
	
	LEVEL3:
	
	MOV VEL1, 0
	MOV VEL2, 0
	MOV VEL3, 1
	
	CALL INIT
	CALL LVL3
	
	MOV AX, 0	
	MOV BX, 0	
	MOV CX, 0	
	MOV DX, 0	
	MOV DI, 0

	MOV SI, 0
	MOV BP, 0
	
	CALL MAKEGRID
	
	.WHILE BP < 2	;NUMBER OF TURNS
		CALL SSS3
		.WHILE DI < 2
			CALL INPUT				
			CALL DELAY			
			
			MOV DX, TEMP
			MOV S1[SI], DX		
			
			INC DI
			ADD SI, 2
		.ENDW				
		
		CALL SWAP		
		CALL CHECKCOMBO
		
		;MOV CX, 3
		;M1:
		;	CALL REGRID			
		;	CALL CHECKALL							
		;LOOP M1
		;CALL CHECKALL	
		
		CALL REGRID	
		CALL FILL
		
		
		CALL CHECKALL	
		
		CALL REGRID	
		CALL FILL
		
		CALL LVL3
		CALL MAKEGRID
		
		MOV SI, 0
		MOV DI, 0				
		
		INC BP
	.ENDW
	
	MOV AX, LVL1_PTS
	;MOV BX, 1
	;MUL BX
	ADD TOTAL_PTS, AX
	
	MOV AX, LVL2_PTS
	;MOV BX, 1
	;MUL BX
	ADD TOTAL_PTS, AX
	
	MOV AX, LVL3_PTS
	;MOV BX, 1
	;MUL BX
	ADD TOTAL_PTS, AX
	
	CALL FILE_HANDLING
	
	CALL CLICK
	CALL DELAY
	
	CALL GAMEOVER

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
EXIT:
MOV AH, 4CH	;END
INT 21H
;;;;;;;;;;;;;;;;;;;;;;;;;;

FILL PROC
	MOV SI, 0
	MOV BX, INDEX
	MOV AX, 0
	.WHILE SI < 98
		MOV AH, ARRAY[SI].ID
		.IF AH == 0
			MOV AL, RAND_ARRAY1[BX]
			MOV ARRAY[SI].ID, AL
			INC BX
			INC INDEX
		.ENDIF
		ADD SI, 2
	.ENDW
	RET
FILL ENDP

SSS PROC USES AX CX DX SI
	;;;;;; PRINT COORDINATES ;;;;;
	
	MOV DL, 10
	MOV AH, 02H
	INT 21H
	
	MOV SI, OFFSET STR1
	MOV CX, LENGTHOF STR1
	CALL PRINTSTR

	MOV SI, OFFSET LV1
	MOV CX, LENGTHOF LV1
	CALL PRINTSTR	
	
	MOV DL, 10
	MOV AH, 02H
	INT 21H

	MOV SI, OFFSET STR2
	MOV CX, LENGTHOF STR2
	CALL PRINTSTR

	MOV SI, OFFSET PLAYER
	MOV CX, LENGTHOF PLAYER
	CALL PRINTSTR	

	MOV DL, 10
	MOV AH, 02H
	INT 21H

	MOV SI, OFFSET STR3
	MOV CX, LENGTHOF STR3
	CALL PRINTSTR

	MOV SI, OFFSET LVL1_PTS
	CALL PRINT

	MOV DL, 10
	MOV AH, 02H
	INT 21H
	
	RET
SSS ENDP	

SSS2 PROC USES AX CX DX SI
	;;;;;; PRINT COORDINATES ;;;;;
	
	MOV DL, 10
	MOV AH, 02H
	INT 21H
	
	MOV SI, OFFSET STR1
	MOV CX, LENGTHOF STR1
	CALL PRINTSTR

	MOV SI, OFFSET LV2
	MOV CX, LENGTHOF LV2
	CALL PRINTSTR	
	
	MOV DL, 10
	MOV AH, 02H
	INT 21H

	MOV SI, OFFSET STR2
	MOV CX, LENGTHOF STR2
	CALL PRINTSTR

	MOV SI, OFFSET PLAYER
	MOV CX, LENGTHOF PLAYER
	CALL PRINTSTR	

	MOV DL, 10
	MOV AH, 02H
	INT 21H

	MOV SI, OFFSET STR3
	MOV CX, LENGTHOF STR3
	CALL PRINTSTR

	MOV SI, OFFSET LVL2_PTS
	CALL PRINT

	MOV DL, 10
	MOV AH, 02H
	INT 21H
	
	RET
SSS2 ENDP	

SSS3 PROC USES AX CX DX SI
	;;;;;; PRINT COORDINATES ;;;;;
	
	MOV DL, 10
	MOV AH, 02H
	INT 21H
	
	MOV SI, OFFSET STR1
	MOV CX, LENGTHOF STR1
	CALL PRINTSTR

	MOV SI, OFFSET LV3
	MOV CX, LENGTHOF LV3
	CALL PRINTSTR	
	
	MOV DL, 10
	MOV AH, 02H
	INT 21H

	MOV SI, OFFSET STR2
	MOV CX, LENGTHOF STR2
	CALL PRINTSTR

	MOV SI, OFFSET PLAYER
	MOV CX, LENGTHOF PLAYER
	CALL PRINTSTR	

	MOV DL, 10
	MOV AH, 02H
	INT 21H

	MOV SI, OFFSET STR3
	MOV CX, LENGTHOF STR3
	CALL PRINTSTR

	MOV SI, OFFSET LVL3_PTS
	CALL PRINT

	MOV DL, 10
	MOV AH, 02H
	INT 21H
	
	RET
SSS3 ENDP	

INIT PROC USES AX BX SI
	MOV SI, 0
	MOV BX, INDEX
	MOV AX, 0
	.WHILE BX < 49
		MOV AL, RAND_ARRAY1[BX]
		MOV ARRAY[SI].ID, AL
		ADD SI, 2
		INC BX
		INC INDEX
	.ENDW
	RET
INIT ENDP

LVL2 PROC
	MOV ARRAY[0].ID, 7
	MOV ARRAY[6].ID, 7
	MOV ARRAY[12].ID, 7
	MOV ARRAY[14].ID, 7
	MOV ARRAY[26].ID, 7
	MOV ARRAY[42].ID, 7
	MOV ARRAY[54].ID, 7
	MOV ARRAY[70].ID, 7
	MOV ARRAY[82].ID, 7
	MOV ARRAY[84].ID, 7
	MOV ARRAY[90].ID, 7
	MOV ARRAY[96].ID, 7
	RET
LVL2 ENDP

LVL3 PROC
	MOV ARRAY[0].ID, 1
	MOV ARRAY[6].ID, 2
	MOV ARRAY[12].ID, 3
	MOV ARRAY[14].ID, 2
	MOV ARRAY[26].ID, 1
	MOV ARRAY[42].ID, 4
	MOV ARRAY[54].ID, 5
	MOV ARRAY[70].ID, 1
	MOV ARRAY[82].ID, 2
	MOV ARRAY[84].ID, 1
	MOV ARRAY[90].ID, 4
	MOV ARRAY[96].ID, 2

	MOV ARRAY[0].ID, 1
	MOV ARRAY[6].ID, 7
	MOV ARRAY[20].ID, 8
	MOV ARRAY[34].ID, 9
	MOV ARRAY[48].ID, 10
	MOV ARRAY[62].ID, 11
	MOV ARRAY[76].ID, 12
	MOV ARRAY[90].ID, 13
	
	MOV ARRAY[42].ID, 7
	MOV ARRAY[44].ID, 8
	MOV ARRAY[46].ID, 9
	MOV ARRAY[50].ID, 11
	MOV ARRAY[52].ID, 12
	MOV ARRAY[54].ID, 13
	RET
LVL3 ENDP

CHECKALL PROC USES AX BX CX DX SI DI BP
		
	MOV AX, 0	
	MOV BX, 0	
	MOV CX, 0	
	MOV DX, 0	
	MOV DI, 0

	MOV SI, 0
	MOV BP, 1
	.WHILE DI < 98
		;MOV ARRAY[DI].ID, 6
		
		.IF DI >= 0 && DI <= 12
			MOV BP, 1
		.ELSEIF DI >= 14 && DI <= 26
			MOV BP, 3
		.ELSEIF DI >= 28 && DI <= 40
			MOV BP, 5
		.ELSEIF DI >= 42 && DI <= 54
			MOV BP, 7
		.ELSEIF DI >= 56 && DI <= 68
			MOV BP, 9
		.ELSEIF DI >= 70 && DI <= 82
			MOV BP, 11
		.ELSEIF DI >= 84 && DI <= 96
			MOV BP, 13
		.ENDIF	
		
		MOV AX, 7
		MUL BP
		MOV BP, AX
		INC BP
	
		MOV SI, DI		
		MOV AX, 0		
		MOV AL, ARRAY[SI].ID
		
		;;;;;;;CHECK RIGHT COMBO;;;;;;;;
		MOV CX, 0	
		.WHILE CX < 3
			.IF SI <= BP 
				.IF ARRAY[SI].ID == AL					
					INC AH
				.ENDIF
				ADD SI, 2				
			.ENDIF	
			INC CX
		.ENDW	
		
		;;;;;;COMBO EXISTS;;;;;
		.IF AH >= 3						
			MOV CX, 0
			MOV SI, DI	

			MOV AX, 0
			MOV BL, ARRAY[SI].POINTS	
			MOV AL, 3
			MUL BL
			.IF VEL1 == 1
				ADD LVL1_PTS, AX
			.ELSEIF VEL2 == 1
				ADD LVL2_PTS, AX
			.ELSEIF VEL3 == 1
				ADD LVL3_PTS, AX
			.ENDIF
			
			.WHILE CX < 3				
				MOV ARRAY[SI].ID, 0					
				ADD SI, 2
				INC CX
			.ENDW			
		.ENDIF	

		MOV SI, DI		
		MOV AX, 0
		MOV AL, ARRAY[SI].ID
		;;;;;;;CHECK DOWN COMBO;;;;;;;;
		MOV CX, 0	
		.WHILE CX < 3				
			.IF ARRAY[SI].ID == AL
				INC AH
			.ENDIF
			ADD SI, 14
			INC CX
		.ENDW	
		
		;;;;;;COMBO EXISTS;;;;;
		.IF AH >= 3
			MOV SI, DI	
			
			MOV AX, 0
			MOV BL, ARRAY[SI].POINTS	
			MOV AL, 3
			MUL BL
			.IF VEL1 == 1
				ADD LVL1_PTS, AX
			.ELSEIF VEL2 == 1
				ADD LVL2_PTS, AX
			.ELSEIF VEL3 == 1
				ADD LVL3_PTS, AX
			.ENDIF
			
			;;;;;;;CHECK DOWN COMBO;;;;;;;;
			MOV CX, 0	
			.WHILE CX < 3				
				MOV ARRAY[SI].ID, 0					
				ADD SI, 14
				INC CX
			.ENDW	
		.ENDIF	
		
		MOV BX, 0
		
		CALL REGRID
		ADD DI, 2
		INC BP
	.ENDW
	
	RET
CHECKALL ENDP

REGRID PROC USES AX BX CX DX SI DI
	MOV SI, 0
	MOV AX, 0
	MOV CX, 0
	
	.WHILE SI < 98		
		.IF	ARRAY[SI].ID == 0			
			MOV AX, SI
		.ENDIF
		ADD SI, 2
	.ENDW
	
	MOV BX, 2
	DIV BX
	INC AX
	
	.IF AX >= 1 && AX <=7
		MOV CX, 0
	.ELSEIF AX >= 8 && AX <=14
		MOV CX, 1
	.ELSEIF AX >= 15 && AX <=21
		MOV CX, 2
	.ELSEIF AX >= 22 && AX <=28
		MOV CX, 3
	.ELSEIF AX >= 29 && AX <=35
		MOV CX, 4
	.ELSEIF AX >= 36 && AX <=42
		MOV CX, 5
	.ELSEIF AX >= 43 && AX <=49
		MOV CX, 6
	.ENDIF	
	
	MOV DX, 0
	.WHILE DX < CX
		MOV SI, 0	
		.WHILE SI < 98
			MOV DI, SI
			SUB DI, 14
			
			.IF DI < 0
				RET
			.ENDIF
			.IF ARRAY[SI].ID >= 7 || ARRAY[DI].ID >= 7		
				RET
			.ENDIF	
			.IF	ARRAY[SI].ID == 0			
				MOV AX, ARRAY[SI]
				MOV BX, ARRAY[DI]
				XCHG AX, BX			;SWAPPING
					
				MOV ARRAY[SI], AX	
				MOV ARRAY[DI], BX	
			.ENDIF
			ADD SI, 2
		.ENDW
		INC DX
	.ENDW
	
	RET
REGRID ENDP

SETINDEX PROC
; AX HOLDS ID OF SELECTED	
; RETURNS INDEX OF SHAPE IN SI
; RETURNS ID OF SHAPE IN AL

	MOV AX, S2
	MOV BX, 2
	MUL BX
	MOV SI, AX
	SUB SI, 2
	
	MOV AX, 0
	MOV AL, ARRAY[SI].ID
	RET
SETINDEX ENDP


CHECKCOMBO PROC 
	
	CALL SETINDEX	
		
	;;;;;;;CHECK LEFT COMBO;;;;;;;; 
	MOV CX, 0	
	.WHILE CX < 3				
		.IF ARRAY[SI].ID == AL
			INC AH
		.ENDIF
		ADD SI, 2
		INC CX
	.ENDW	
	
	;;;;;;COMBO EXISTS;;;;;
	.IF AH >= 3
		MOV AL, 1
		CALL COMBO
		RET
	.ENDIF
	
	CALL SETINDEX
	
	;;;;;;;CHECK MIDDLE COMBO;;;;;;;;
				
	.IF ARRAY[SI+2].ID == AL
		INC AH
	.ENDIF
	.IF ARRAY[SI-2].ID == AL
		INC AH
	.ENDIF		
	
	;;;;;;COMBO EXISTS;;;;;
	.IF AH >= 2
		MOV AL, 2
		CALL COMBO
		RET
	.ENDIF		
	
	CALL SETINDEX
	
	;;;;;;;CHECK RIGHT COMBO;;;;;;;;
	MOV CX, 0	
	.WHILE CX < 3				
		.IF ARRAY[SI].ID == AL
			INC AH
		.ENDIF
		SUB SI, 2
		INC CX
	.ENDW	
	
	;;;;;;COMBO EXISTS;;;;;
	.IF AH >= 3
		MOV AL, 3
		CALL COMBO
		RET
	.ENDIF	
	
	CALL SETINDEX
	
	;;;;;;;CHECK UP COMBO;;;;;;;;
	MOV CX, 0	
	.WHILE CX < 3				
		.IF ARRAY[SI].ID == AL
			INC AH
		.ENDIF
		SUB SI, 14
		INC CX
	.ENDW	
	
	;;;;;;COMBO EXISTS;;;;;
	.IF AH >= 3
		MOV AL, 4
		CALL COMBO
		RET
	.ENDIF	
	
	CALL SETINDEX
	
	;;;;;;;CHECK MIDDLE-UP COMBO;;;;;;;;
	.IF ARRAY[SI+14].ID == AL
		INC AH
	.ENDIF
	.IF ARRAY[SI-14].ID == AL
		INC AH
	.ENDIF		
	
	;;;;;;COMBO EXISTS;;;;;
	.IF AH >= 2
		MOV AL, 5
		CALL COMBO
		RET
	.ENDIF	
	
	CALL SETINDEX
	
	;;;;;;;CHECK DOWN COMBO;;;;;;;;
	MOV CX, 0	
	.WHILE CX < 3				
		.IF ARRAY[SI].ID == AL
			INC AH
		.ENDIF
		ADD SI, 14
		INC CX
	.ENDW	
	
	;;;;;;COMBO EXISTS;;;;;
	.IF AH >= 3
		MOV AL, 6
		CALL COMBO
		RET
	.ENDIF	
	
	RET
CHECKCOMBO ENDP

COMBO PROC 
	PUSH AX

	CALL SETINDEX
	
	MOV AX, 0
	MOV BL, ARRAY[SI].POINTS	
	MOV AL, 3
	MUL BL
	.IF VEL1 == 1
		ADD LVL1_PTS, AX
	.ELSEIF VEL2 == 1
		ADD LVL2_PTS, AX
	.ELSEIF VEL3 == 1
		ADD LVL3_PTS, AX
	.ENDIF

	POP AX	;WE ONLY NEED SI		
	
	MOV BX, 0
	.IF AL == 1
		;;;;;;;LEFT COMBO;;;;;;;;
		MOV CX, 0	
		.WHILE CX < 3				
			MOV ARRAY[SI].ID, 0					
			ADD SI, 2
			INC CX
		.ENDW		
	.ELSEIF AL == 2
		;;;;;;;MIDDLE COMBO;;;;;;;;
		MOV CX, 0	
		SUB SI, 2
		.WHILE CX < 3				
			MOV ARRAY[SI].ID, 0					
			ADD SI, 2
			INC CX
		.ENDW	
	.ELSEIF AL == 3
		;;;;;;; RIGHT COMBO;;;;;;;;
		MOV CX, 0	
		.WHILE CX < 3				
			MOV ARRAY[SI].ID, 0					
			SUB SI, 2
			INC CX
		.ENDW
	.ELSEIF AL == 4
		;;;;;;; UP COMBO;;;;;;;;
		MOV CX, 0	
		.WHILE CX < 3				
			MOV ARRAY[SI].ID, 0					
			SUB SI, 14
			INC CX
		.ENDW	
	.ELSEIF AL == 5
		;;;;;;; MIDDLE-UP COMBO;;;;;;;;
		MOV CX, 0	
		SUB SI, 14
		.WHILE CX < 3				
			MOV ARRAY[SI].ID, 0					
			ADD SI, 14
			INC CX
		.ENDW	
	.ELSEIF AL == 6
		;;;;;;; DOWN COMBO;;;;;;;;
		MOV CX, 0	
		.WHILE CX < 3				
			MOV ARRAY[SI].ID, 0					
			ADD SI, 14
			INC CX
		.ENDW	
	.ENDIF	
	
	RET
COMBO ENDP
	
SWAP PROC USES AX BX SI DI
;AX USED FOR HOLDING 1ST SELECTED CELL
;BX USED FOR HOLDING 2ND SELECTED CELL
;SI USED FOR HOLDING 1ST SHAPE
;DI USED FOR HOLDING 2ND SHAPE

	;;;;;;;;; CHECKING FOR SWAPPING CONDITIONS ;;;;;;;;	
	
	;LEFT
	MOV AX, S1
	MOV T, AX
	SUB T, 1
	MOV AX, T
	MOV L, AX
	
	;RIGHT
	MOV AX, S1
	MOV T, AX
	ADD T, 1
	MOV AX, T
	MOV R, AX
	
	;UP
	MOV AX, S1
	MOV T, AX
	SUB T, 7
	MOV AX, T
	MOV U, AX
	
	;DOWN
	MOV AX, S1
	MOV T, AX
	ADD T, 7
	MOV AX, T
	MOV D, AX
	
	MOV AX, S2
	
	.IF AX != U 
		.IF AX != D
			.IF AX != L
				.IF AX != R
					RET
				.ENDIF
			.ENDIF
		.ENDIF
	.ENDIF
		
	
	;;;;;;;; IF CONDITIONS ARE MET THEN SWAP ;;;;;;;;

	MOV AX, S1
	MOV BX, 2
	MUL BX
	MOV SI, AX
	SUB SI, 2
	
	MOV AX, S2
	MOV BX, 2
	MUL BX
	MOV DI, AX
	SUB DI, 2
	
	MOV AX, 0
	MOV BX, 0	
	
	.IF ARRAY[SI].ID == 6 || ARRAY[DI].ID == 6
		CALL BOMB
		RET
	.ELSEIF ARRAY[SI].ID >= 7 || ARRAY[DI].ID >= 7		
		RET
	.ENDIF	
	
	MOV AX, ARRAY[SI]	
	MOV BX, ARRAY[DI]
	XCHG AX, BX			;SWAPPING
		
	MOV ARRAY[SI], AX	
	MOV ARRAY[DI], BX	
			
	RET
SWAP ENDP

BOMB PROC
	
	.IF ARRAY[SI].ID == 6 	
		PUSH SI
		MOV AL, ARRAY[DI].ID
		MOV SI, 0
		.WHILE SI < 98	
			.IF	ARRAY[SI].ID == AL
				MOV ARRAY[SI].ID, 0	
			.ENDIF
			ADD SI, 2
		.ENDW	
		POP SI
		MOV ARRAY[SI].ID, 0
	.ELSEIF ARRAY[DI].ID == 6
		PUSH DI
		MOV AL, ARRAY[SI].ID
		MOV DI, 0
		.WHILE DI < 98	
			.IF	ARRAY[DI].ID == AL
				MOV ARRAY[DI].ID, 0	
			.ENDIF
			ADD DI, 2
		.ENDW
		POP DI
		MOV ARRAY[DI].ID, 0
	.ENDIF	
	
	RET
BOMB ENDP

SELECTED PROC USES AX 
;AX = ROW/COL SELECTED

	MOV TEMP, AX	
	RET
SELECTED ENDP

DELAY PROC USES CX DX
	MOV CX, 250
	
	L1:
		MOV DX, 1000
		L2:
			DEC DX
		CMP DX, 0
		JNE L2
	LOOP L1
	
	RET
DELAY ENDP

INPUTSTR PROC USES AX BX SI
	L1:
		MOV AH, 1
		INT 21H
		
		CMP AL, 13
		JE EXITINPUT
		
		MOV [SI], AL
		INC SI
	JMP L1
		
	EXITINPUT:
		MOV DL, 0
		MOV [SI], DL		
	RET
INPUTSTR ENDP	

DISPLAY PROC USES AX BX CX DX SI DI
	MOV CTR, 0
	.WHILE CTR < DI
		MOV AH, 0AH	;WRITE CHARACTER AT CURSOR POSITION		
		MOV AL, [SI]	;CHARACTER
		INC SI
		;MOV BL, 	;FOR COLOR
		MOV CX, 1	;NUMBER OF TIMES TO PRINT CHARACTER
		INT 10H

		MOV AH, 02H	;SET CURSOR POSITION
		INC DL		;WRITE ONE SPACE/COLUMN AFTER 
		INT 10H

		INC CTR
	.ENDW		
	RET
DISPLAY ENDP

BORDER PROC USES AX BX CX DX SI DI

;BX = CTR
;CX = X
;DX = Y
;SI = X LEN
;DI = Y LEN

	MOV BX, 0

	.WHILE BX < SI
		MOV AH, 0CH
		MOV AL, 15
		INT 10H

		INC CX

		INC BX
	.ENDW

	MOV BX, 0
	.WHILE BX < DI
		MOV AH, 0CH
		MOV AL, 15
		INT 10H

		INC DX

		INC BX
	.ENDW

	MOV BX, 0
	.WHILE BX < SI
		MOV AH, 0CH
		MOV AL, 15
		INT 10H

		DEC CX

		INC BX
	.ENDW

	MOV BX, 0
	.WHILE BX < DI
		MOV AH, 0CH
		MOV AL, 15
		INT 10H

		DEC DX

		INC BX
	.ENDW

	RET
BORDER ENDP

CLICK PROC USES AX BX CX
	MOV AX, 5
	INT 33H

	.WHILE AX == 0
		MOV AX, 5
		INT 33H
	.ENDW
	
	RET
CLICK ENDP

TITLESCREEN PROC USES AX BX CX DX SI DI

	;;;;;; TAKING USERNAME INPUT ;;;;;;;

	MOV SI, 0
	MOV CX, 12
	T1:
		MOV DL, TXT[SI]
		INC SI
		MOV AH, 02H
		INT 21H
	LOOP T1

	MOV SI, OFFSET PLAYER
	CALL INPUTSTR
	
	MOV AH, 0	;SET VIDEO MODE
	MOV AL, 6	;SCREEN MODE
	INT 10H
	
	;;;;; DISPLAYING TEXT ;;;;;

	MOV AH, 02H	;SET CURSOR POSITION
	MOV BH, 0	;SET PAGE NUMBER
	MOV DH, 8	;ROW
	MOV DL, 37	;COLUMN
	INT 10H

	MOV SI, OFFSET GAME_TITLE
	MOV DI, LENGTHOF GAME_TITLE
	CALL DISPLAY

	MOV AH, 02H	;SET CURSOR POSITION
	MOV BH, 0	;SET PAGE NUMBER
	MOV DH, 15	;ROW
	MOV DL, 37	;COLUMN
	INT 10H

	MOV SI, OFFSET PLAYER
	MOV DI, LENGTHOF PLAYER
	CALL DISPLAY
	
	;;;;;; DRAWING A BOX ;;;;;;;;

	MOV CX, 245	;X-COORDINATE FOR RECTANGLE
	MOV DX, 55	;Y-COORDINATE FOR RECTANGLE
	
	MOV SI, 150
	MOV DI, 20
	CALL BORDER

	MOV CX, 275	;X-COORDINATE FOR RECTANGLE
	MOV DX, 110	;Y-COORDINATE FOR RECTANGLE
	
	MOV SI, 80
	MOV DI, 20
	CALL BORDER
	
	RET
TITLESCREEN ENDP

HOWTOPLAY PROC USES AX BX CX DX SI DI
	MOV AH, 0
	MOV AL, 6
	INT 10H
	
	MOV BH, 0
	
	MOV AH, 2
	MOV DH, 2
	MOV DL, 35
	INT 10H
	
	MOV DX, OFFSET HOWTO1
	MOV AH, 9
	INT 21H
	
	MOV AH, 2
	MOV DH, 9
	MOV DL, 6
	INT 10H
	
	MOV DX, OFFSET HOWTO2
	MOV AH, 9
	INT 21H
	
	MOV AH, 2
	MOV DH, 11
	MOV DL, 6
	INT 10H
	
	MOV DX, OFFSET HOWTO3
	MOV AH, 9
	INT 21H
	
	MOV AH, 2
	MOV DH, 13
	MOV DL, 6
	INT 10H
	
	MOV DX, OFFSET HOWTO4
	MOV AH, 9
	INT 21H
	
	MOV AH, 2
	MOV DH, 15
	MOV DL, 6
	INT 10H
	
	MOV DX, OFFSET HOWTO5
	MOV AH, 9
	INT 21H
	
	
	;;;;;; DRAWING A BOX ;;;;;;;;

	MOV CX, 40	;X-COORDINATE FOR RECTANGLE
	MOV DX, 50	;Y-COORDINATE FOR RECTANGLE
	
	MOV SI, 550
	MOV DI, 100
	CALL BORDER
	
	RET
HOWTOPLAY ENDP

GRID PROC USES AX BX CX DX
		PUSH CX
		PUSH DX
		
		MOV BX, 0
		.WHILE BX < 8 ;8 ROWS
			PUSH BX
			PUSH CX
			
			MOV BX, 0
			.WHILE BX < 2 ;RUN 2 TIMES BECAUSE 2 X-AXIS PIXEL = 1 Y-AXIS PIXEL
				PUSH BX
				
				MOV BX, 0
				.WHILE BX < 140
					MOV AH, 0CH
					MOV AL, GRIDCOLOR
					INT 10H
					
					INC CX
					
					INC BX
				.ENDW
				POP BX
				INC BX
			.ENDW
			POP CX
			POP BX
			
			INC BX
			ADD DX, 20
		.ENDW
		
		POP DX
		POP CX
		
		MOV BX, 0
		.WHILE BX < 8 ;8 COLUMNS
			PUSH BX
			PUSH DX
			
			MOV BX, 0
			.WHILE BX < 140
				MOV AH, 0CH
				MOV AL, GRIDCOLOR
				INT 10H
				
				INC DX
				
				INC BX
			.ENDW
			
			POP DX
			POP BX
			
			INC BX
			ADD CX, 40
		.ENDW
		RET
	GRID ENDP

INPUT PROC USES AX BX CX DX SI

	MOV AX, 1
	INT 33h

	;;;;;;; GET COORDINATES ;;;;;;
	MOV AX, 5
	INT 33H

	.WHILE AX == 0
		MOV AX, 3
		INT 33H
		MOV X, CX
		MOV Y, DX
	
		MOV AX, 5
		INT 33H
	.ENDW		
	
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
	;;;;;; 1ST ROW ;;;;;;;;
	.IF Y >= 30 && Y <= 50
		.IF X >= 180 && X <= 220  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR 49
			MOV [SI+7], BYTE PTR '1'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 1			
			CALL SELECTED
		.ELSEIF X >= 220 && X <= 260  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '1'
			MOV [SI+7], BYTE PTR '2'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 2			
			CALL SELECTED
		.ELSEIF X >= 260 && X <= 300  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '1'
			MOV [SI+7], BYTE PTR '3'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 3			
			CALL SELECTED
		.ELSEIF X >= 300 && X <= 340  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '1'
			MOV [SI+7], BYTE PTR '4'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 4		
			CALL SELECTED
		.ELSEIF X >= 340 && X <= 380  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '1'
			MOV [SI+7], BYTE PTR '5'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 5			
			CALL SELECTED
		.ELSEIF X >= 380 && X <= 420  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '1'
			MOV [SI+7], BYTE PTR '6'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 6			
			CALL SELECTED
		.ELSEIF X >= 420 && X <= 460  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '1'
			MOV [SI+7], BYTE PTR '7'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR	

			MOV AX, 7			
			CALL SELECTED
		.ENDIF
	;;;;;; 2ND ROW ;;;;;;;;
	.ELSEIF Y >= 50 && Y <= 70
		.IF X >= 180 && X <= 220  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR 50
			MOV [SI+7], BYTE PTR '1'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 8			
			CALL SELECTED
		.ELSEIF X >= 220 && X <= 260  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '2'
			MOV [SI+7], BYTE PTR '2'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 9			
			CALL SELECTED
		.ELSEIF X >= 260 && X <= 300  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '2'
			MOV [SI+7], BYTE PTR '3'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 10			
			CALL SELECTED
		.ELSEIF X >= 300 && X <= 340  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '2'
			MOV [SI+7], BYTE PTR '4'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 11			
			CALL SELECTED
		.ELSEIF X >= 340 && X <= 380  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '2'
			MOV [SI+7], BYTE PTR '5'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 12			
			CALL SELECTED
		.ELSEIF X >= 380 && X <= 420  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '2'
			MOV [SI+7], BYTE PTR '6'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 13			
			CALL SELECTED
		.ELSEIF X >= 420 && X <= 460  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '2'
			MOV [SI+7], BYTE PTR '7'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR	

			MOV AX, 14			
			CALL SELECTED			
		.ENDIF
	;;;;;; 3RD ROW ;;;;;;;;	
	.ELSEIF Y >= 70 && Y <= 90
		.IF X >= 180 && X <= 220  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR 51
			MOV [SI+7], BYTE PTR '1'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 15			
			CALL SELECTED	
		.ELSEIF X >= 220 && X <= 260  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '3'
			MOV [SI+7], BYTE PTR '2'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 16			
			CALL SELECTED	
		.ELSEIF X >= 260 && X <= 300  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '3'
			MOV [SI+7], BYTE PTR '3'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 17			
			CALL SELECTED	
		.ELSEIF X >= 300 && X <= 340  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '3'
			MOV [SI+7], BYTE PTR '4'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 18			
			CALL SELECTED	
		.ELSEIF X >= 340 && X <= 380  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '3'
			MOV [SI+7], BYTE PTR '5'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 19			
			CALL SELECTED	
		.ELSEIF X >= 380 && X <= 420  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '3'
			MOV [SI+7], BYTE PTR '6'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 20			
			CALL SELECTED	
		.ELSEIF X >= 420 && X <= 460  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '3'
			MOV [SI+7], BYTE PTR '7'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR		

			MOV AX, 21			
			CALL SELECTED	
		.ENDIF
	;;;;;; 4TH ROW ;;;;;;;;	
	.ELSEIF Y >= 90 && Y <= 110
		.IF X >= 180 && X <= 220  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR 52
			MOV [SI+7], BYTE PTR '1'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 22			
			CALL SELECTED	
		.ELSEIF X >= 220 && X <= 260  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '4'
			MOV [SI+7], BYTE PTR '2'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 23	
			CALL SELECTED
		.ELSEIF X >= 260 && X <= 300  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '4'
			MOV [SI+7], BYTE PTR '3'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 24
			CALL SELECTED
		.ELSEIF X >= 300 && X <= 340  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '4'
			MOV [SI+7], BYTE PTR '4'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 25
			CALL SELECTED
		.ELSEIF X >= 340 && X <= 380  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '4'
			MOV [SI+7], BYTE PTR '5'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 26		
			CALL SELECTED
		.ELSEIF X >= 380 && X <= 420  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '4'
			MOV [SI+7], BYTE PTR '6'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 27		
			CALL SELECTED
		.ELSEIF X >= 420 && X <= 460  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '4'
			MOV [SI+7], BYTE PTR '7'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR

			MOV AX, 28		
			CALL SELECTED
		.ENDIF
	;;;;;; 5TH ROW ;;;;;;;
	.ELSEIF Y >= 110 && Y <= 130
		.IF X >= 180 && X <= 220  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR 53
			MOV [SI+7], BYTE PTR '1'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 29
			CALL SELECTED
		.ELSEIF X >= 220 && X <= 260  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '5'
			MOV [SI+7], BYTE PTR '2'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 30		
			CALL SELECTED
		.ELSEIF X >= 260 && X <= 300  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '5'
			MOV [SI+7], BYTE PTR '3'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 31	
			CALL SELECTED
		.ELSEIF X >= 300 && X <= 340  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '5'
			MOV [SI+7], BYTE PTR '4'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 32	
			CALL SELECTED
		.ELSEIF X >= 340 && X <= 380  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '5'
			MOV [SI+7], BYTE PTR '5'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 33	
			CALL SELECTED
		.ELSEIF X >= 380 && X <= 420  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '5'
			MOV [SI+7], BYTE PTR '6'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 34	
			CALL SELECTED
		.ELSEIF X >= 420 && X <= 460  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '5'
			MOV [SI+7], BYTE PTR '7'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR			
			
			MOV AX, 35
			CALL SELECTED
		.ENDIF
	;;;;;; 6TH ROW ;;;;;;;
	.ELSEIF Y >= 130 && Y <= 150
		.IF X >= 180 && X <= 220  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR 54
			MOV [SI+7], BYTE PTR '1'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 36
			CALL SELECTED
		.ELSEIF X >= 220 && X <= 260  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '6'
			MOV [SI+7], BYTE PTR '2'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 37
			CALL SELECTED
		.ELSEIF X >= 260 && X <= 300  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '6'
			MOV [SI+7], BYTE PTR '3'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 38
			CALL SELECTED
		.ELSEIF X >= 300 && X <= 340  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '6'
			MOV [SI+7], BYTE PTR '4'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 39
			CALL SELECTED
		.ELSEIF X >= 340 && X <= 380  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '6'
			MOV [SI+7], BYTE PTR '5'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 40
			CALL SELECTED
		.ELSEIF X >= 380 && X <= 420  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '6'
			MOV [SI+7], BYTE PTR '6'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 41
			CALL SELECTED
		.ELSEIF X >= 420 && X <= 460  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '6'
			MOV [SI+7], BYTE PTR '7'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR		

			MOV AX, 42
			CALL SELECTED
		.ENDIF
	;;;;;; 7TH ROW ;;;;;;;
	.ELSEIF Y >= 150 && Y <= 170
		.IF X >= 180 && X <= 220  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR 55
			MOV [SI+7], BYTE PTR '1'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 43
			CALL SELECTED
		.ELSEIF X >= 220 && X <= 260  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '7'
			MOV [SI+7], BYTE PTR '2'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 44
			CALL SELECTED
		.ELSEIF X >= 260 && X <= 300  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '7'
			MOV [SI+7], BYTE PTR '3'
			MOV CX, LENGTHOF CELL
			CALL PRINTSTR
			
			MOV AX, 45
			CALL SELECTED
		.ELSEIF X >= 300 && X <= 340  
			;MOV SI, OFFSET CELL
			;MOV [SI+5], BYTE PTR '7'
			;MOV [SI+7], BYTE PTR '4'
			;MOV CX, LENGTHOF CELL
			;CALL PRINTSTR
			
			MOV AX, 46
			CALL SELECTED
		.ELSEIF X >= 340 && X <= 380  
			;MOV SI, OFFSET CELL
			;MOV [SI+5], BYTE PTR '7'
			;MOV [SI+7], BYTE PTR '5'
			;MOV CX, LENGTHOF CELL
			;CALL PRINTSTR
			
			MOV AX, 47
			CALL SELECTED
		.ELSEIF X >= 380 && X <= 420  
			;MOV SI, OFFSET CELL
			;MOV [SI+5], BYTE PTR '7'
			;MOV [SI+7], BYTE PTR '6'
			;MOV CX, LENGTHOF CELL
			;CALL PRINTSTR
			
			MOV AX, 48
			CALL SELECTED
		.ELSEIF X >= 420 && X <= 460  
			MOV SI, OFFSET CELL
			MOV [SI+5], BYTE PTR '7'
			MOV [SI+7], BYTE PTR '7'
			MOV CX, LENGTHOF CELL
			;CALL PRINTSTR			
			
			MOV AX, 49
			CALL SELECTED
		.ENDIF
	
	.ELSE
		MOV SI, OFFSET OUTOFBOUNDS
		MOV CX, LENGTHOF OUTOFBOUNDS
		
		CALL PRINTSTR
	.ENDIF			
	
	RET
INPUT ENDP

PRINT PROC USES AX BX CX DX

	MOV AX, [SI]
	MOV BL, 10
	L1:
		CMP AL, 0
		JE L2
		
		DIV BL
		MOV CL, AH
		MOV CH, 0
		PUSH CX
		INC CTR
		MOV AH, 0
		JMP L1
			
	L2:
		CMP CTR, 0
		JE PRINTEXIT
		POP DX
		ADD DX, 48
		MOV AH, 2
		INT 21H
		DEC CTR
		JMP L2
		
	PRINTEXIT:	
		MOV CTR, 0
	RET
PRINT ENDP

PRINTSTR PROC USES AX BX CX DX				
	L1:
		MOV AX, [SI]				
		MOV DX, AX
		MOV AH, 02H
		INT 21H
		INC SI
	LOOP L1
		
	PRINTSTREXIT:									
	RET
PRINTSTR ENDP

SQUARE PROC USES AX BX CX DX
	MOV BX, 0
	.WHILE BX < 28
		MOV AH, 0CH
		MOV AL, SQUARE_COLOR
		INT 10H
		
		INC CX
		
		INC BX
	.ENDW
	
	MOV BX, 0
	.WHILE BX < 14
		MOV AH, 0CH
		MOV AL, SQUARE_COLOR
		INT 10H
		
		INC DX
		
		INC BX
	.ENDW
	
	MOV BX, 0
	.WHILE BX < 28
		MOV AH, 0CH
		MOV AL, SQUARE_COLOR
		INT 10H
		
		DEC CX
		
		INC BX
	.ENDW
	
	MOV BX, 0
	.WHILE BX < 14
		MOV AH, 0CH
		MOV AL, SQUARE_COLOR
		INT 10H
		
		DEC DX
		
		INC BX
	.ENDW
	RET
SQUARE ENDP
	
RECTANGLE PROC USES AX BX CX DX
	ADD DX, 2
	MOV BX, 0
	.WHILE BX < 28
		MOV AH, 0CH
		MOV AL, RECTANGLE_COLOR
		INT 10H
		
		INC CX
		
		INC BX
	.ENDW
	
	MOV BX, 0
	.WHILE BX < 10
		MOV AH, 0CH
		MOV AL, RECTANGLE_COLOR
		INT 10H
		
		INC DX
		
		INC BX
	.ENDW
	
	MOV BX, 0
	.WHILE BX < 28
		MOV AH, 0CH
		MOV AL, RECTANGLE_COLOR
		INT 10H
		
		DEC CX
		
		INC BX
	.ENDW
	
	MOV BX, 0
	.WHILE BX < 10
		MOV AH, 0CH
		MOV AL, RECTANGLE_COLOR
		INT 10H
		
		DEC DX
		
		INC BX
	.ENDW
	RET
RECTANGLE ENDP

TRIANGLE PROC USES AX BX CX DX
	ADD CX, 15
	MOV BX, 0
	.WHILE BX < 14
		MOV AH, 0CH
		MOV AL, TRIANGLE_COLOR
		INT 10H
		
		INC CX
		INC DX
		
		INC BX
	.ENDW
	
	MOV BX, 0
	.WHILE BX < 28
		MOV AH, 0CH
		MOV AL, TRIANGLE_COLOR
		INT 10H
		
		DEC CX
		
		INC BX
	.ENDW
	
	MOV BX, 0
	.WHILE BX < 14
		MOV AH, 0CH
		MOV AL, TRIANGLE_COLOR
		INT 10H
		
		INC CX
		DEC DX
		
		INC BX
	.ENDW
	RET
TRIANGLE ENDP

DIAMOND PROC USES AX BX CX DX
	ADD CX, 15
	MOV BX, 0
	.WHILE BX < 7
		MOV AH, 0CH
		MOV AL, DIAMOND_COLOR
		INT 10H
		
		ADD CX, 2
		INC DX
		
		INC BX
	.ENDW
	
	MOV BX, 0
	.WHILE BX < 7
		MOV AH, 0CH
		MOV AL, DIAMOND_COLOR
		INT 10H
		
		SUB CX, 2
		INC DX
		
		INC BX
	.ENDW
	
	MOV BX, 0
	.WHILE BX < 7
		MOV AH, 0CH
		MOV AL, DIAMOND_COLOR
		INT 10H
		
		SUB CX, 2
		DEC DX
		
		INC BX
	.ENDW
	
	MOV BX, 0
	.WHILE BX < 7
		MOV AH, 0CH
		MOV AL, DIAMOND_COLOR
		INT 10H
		
		ADD CX, 2
		DEC DX
		
		INC BX
	.ENDW
	RET
DIAMOND ENDP

PENTAGON PROC USES AX BX CX DX
	ADD CX, 15
	MOV BX, 0
	.WHILE BX < 7
		MOV AH, 0CH
		MOV AL, PENTAGON_COLOR
		INT 10H
		
		ADD CX, 2
		INC DX
		
		INC BX
	.ENDW
	
	MOV BX, 0
	.WHILE BX < 7
		MOV AH, 0CH
		MOV AL, PENTAGON_COLOR
		INT 10H
		
		DEC CX
		INC DX
		
		INC BX
	.ENDW
	
	MOV BX, 0
	.WHILE BX < 14
		MOV AH, 0CH
		MOV AL, PENTAGON_COLOR
		INT 10H
		
		DEC CX
		
		INC BX
	.ENDW
	
	MOV BX, 0
	.WHILE BX < 7
		MOV AH, 0CH
		MOV AL, PENTAGON_COLOR
		INT 10H
		
		DEC CX
		DEC DX
		
		INC BX
	.ENDW
	
	MOV BX, 0
	.WHILE BX < 7
		MOV AH, 0CH
		MOV AL, PENTAGON_COLOR
		INT 10H
		
		ADD CX, 2
		DEC DX
		
		INC BX
	.ENDW
	RET
PENTAGON ENDP
	
COLOR_BOMB PROC USES AX BX CX DX
	MOV BX, 0
	MOV AL, 1
	.WHILE BX < 15
		PUSH BX
		PUSH CX
		
		MOV BX, 0
		.WHILE BX < 30
			MOV AH, 0CH
			INT 10H
			
			INC CX
			INC BX
		.ENDW
		POP CX
		POP BX
		
		INC AL
		.IF AL == 0
			INC AL
		.ENDIF
		INC BX
		INC DX
	.ENDW
	RET
COLOR_BOMB ENDP
	
SHAPES PROC USES AX BX CX DX SI
	MOV BX, 0
	MOV SI, 0
	.WHILE BX < 7
		PUSH BX
		PUSH CX
		MOV BX, 0
		.WHILE BX < 7
			MOV AL, ARRAY[SI].ID
			.IF AL == 0
				;NO SHAPE
			.ELSEIF AL == 1
				CALL SQUARE
			.ELSEIF AL == 2
				CALL RECTANGLE
			.ELSEIF AL == 3
				CALL TRIANGLE
			.ELSEIF AL == 4
				CALL DIAMOND			
			.ELSEIF AL == 5
				CALL PENTAGON
			.ELSEIF AL == 6
				CALL COLOR_BOMB
			.ELSEIF AL >= 7 && AL <= 13
				;NO SHAPE
			.ELSE
				CALL SQUARE
			.ENDIF
			ADD CX, 40
			
			ADD SI, 2
			INC BX
		.ENDW
		ADD DX, 20
		
		POP CX
		POP BX
		INC BX
	.ENDW
	RET
SHAPES ENDP
	
MAKEGRID PROC ;USES AX CX DX
	;SET VIDEO OUTPUT MODE
	MOV AH, 0
	MOV AL, 14
	INT 10H
	
	;SET BACKGROUND COLOR
	MOV AH, 0BH
	MOV BH, 00H
	MOV BL, 0 ;COLOR
	INT 10H

	MOV CX, 180
	MOV DX, 30
	CALL GRID

	MOV CX, 186
	MOV DX, 33
	CALL SHAPES
	
	MOV AX, 0
	MOV CX, 0
	MOV DX, 0	
	
	RET
MAKEGRID ENDP

FILE_HANDLING PROC USES AX BX CX DX SI DI
		CALL READ_HS
		
		;CREATE FILE
		MOV DX, OFFSET FILENAME
		MOV CX, 0
		MOV AH, 3CH
		INT 21H
		
		;OPEN FILE
		MOV DX, OFFSET FILENAME
		MOV AL, 2
		MOV AH, 3DH
		INT 21H
		
		MOV HANDLER, AX
		
		MOV DX, OFFSET PLAYER
		MOV CX, LENGTHOF PLAYER
		DEC CX
		MOV AH, 40H
		MOV BX, HANDLER
		INT 21H
		
		MOV DX, OFFSET NEWLINE
		MOV CX, 1
		MOV AH, 40H
		MOV BX, HANDLER
		INT 21H
		
		MOV DX, OFFSET LVL1_STR
		MOV CX, LENGTHOF LVL1_STR
		DEC CX
		MOV AH, 40H
		MOV BX, HANDLER
		INT 21H
		
		MOV AX, LVL1_PTS
		MOV SI, OFFSET LVL1_PTS_STR
		CALL TO_STR
		
		MOV DX, OFFSET LVL1_PTS_STR
		MOV CX, LEN
		MOV AH, 40H
		MOV BX, HANDLER
		INT 21H
		
		MOV DX, OFFSET NEWLINE
		MOV CX, 1
		MOV AH, 40H
		MOV BX, HANDLER
		INT 21H
		
		MOV DX, OFFSET LVL2_STR
		MOV CX, LENGTHOF LVL2_STR
		DEC CX
		MOV AH, 40H
		MOV BX, HANDLER
		INT 21H
		
		MOV AX, LVL2_PTS
		MOV SI, OFFSET LVL2_PTS_STR
		CALL TO_STR
		
		MOV DX, OFFSET LVL2_PTS_STR
		MOV CX, LEN
		MOV AH, 40H
		MOV BX, HANDLER
		INT 21H
		
		MOV DX, OFFSET NEWLINE
		MOV CX, 1
		MOV AH, 40H
		MOV BX, HANDLER
		INT 21H
		
		MOV DX, OFFSET LVL3_STR
		MOV CX, LENGTHOF LVL3_STR
		DEC CX
		MOV AH, 40H
		MOV BX, HANDLER
		INT 21H
		
		MOV AX, LVL3_PTS
		MOV SI, OFFSET LVL3_PTS_STR
		CALL TO_STR
		
		MOV DX, OFFSET LVL3_PTS_STR
		MOV CX, LEN
		MOV AH, 40H
		MOV BX, HANDLER
		INT 21H
		
		MOV DX, OFFSET NEWLINE
		MOV CX, 1
		MOV AH, 40H
		MOV BX, HANDLER
		INT 21H
		
		MOV DX, OFFSET HS_STR
		MOV CX, LENGTHOF HS_STR
		DEC CX
		MOV AH, 40H
		MOV BX, HANDLER
		INT 21H
		
		MOV AX, TOTAL_PTS
		.IF AX > HIGHSCORE
			MOV AX, TOTAL_PTS
			MOV SI, OFFSET TOTAL_PTS_STR
			CALL TO_STR
			
			MOV DX, OFFSET TOTAL_PTS_STR
			MOV CX, LEN
			MOV AH, 40H
			MOV BX, HANDLER
			INT 21H
		.ELSE
			MOV AX, HIGHSCORE
			MOV SI, OFFSET HIGHSCORE_STR
			CALL TO_STR
			
			MOV DX, OFFSET HIGHSCORE_STR
			MOV CX, LEN
			MOV AH, 40H
			MOV BX, HANDLER
			INT 21H
		.ENDIF
		
		MOV DX, OFFSET NEWLINE
		MOV CX, 1
		MOV AH, 40H
		MOV BX, HANDLER
		INT 21H
		
		;CLOSE FILE
		MOV AH, 3EH
		INT 21H
		
		RET
	FILE_HANDLING ENDP
	
	READ_HS PROC USES AX BX CX DX SI DI
		MOV COUNTER, 0
		
		;OPEN FILE
		MOV DX, OFFSET FILENAME
		MOV AL, 0
		MOV AH, 3DH
		INT 21H
		
		;IF FILE DOES NOT EXIST, JUMP TO EXIT
		JC EXIT_READ_HS
		
		MOV HANDLER, AX
		
		;READ CHAR BY CHAR
		.WHILE COUNTER < 4
			MOV BX, HANDLER
			MOV DX, OFFSET CHAR
			MOV AH, 3FH
			MOV CX, 1
			INT 21H
			
			MOV DL, CHAR
			.IF DL == 10
				INC COUNTER
			.ENDIF
		.ENDW
		
		MOV COUNTER, 0
		.WHILE COUNTER < 15
			MOV BX, HANDLER
			MOV DX, OFFSET CHAR
			MOV AH, 3FH
			MOV CX, 1
			INT 21H
			
			INC COUNTER
		.ENDW
		
		MOV COUNTER, 0
		MOV SI, OFFSET HIGHSCORE_STR
		.WHILE COUNTER == 0
			MOV BX, HANDLER
			MOV DX, OFFSET CHAR
			MOV AH, 3FH
			MOV CX, 1
			INT 21H
			
			MOV DL, CHAR
			.IF DL == 10
				JMP EXIT_LOOP
			.ENDIF
			
			MOV [SI], DL
			INC SI
		.ENDW
		
		EXIT_LOOP:
		
		;CLOSE FILE
		MOV AH, 3EH
		MOV BX, HANDLER
		INT 21H
		
		MOV SI, OFFSET HIGHSCORE_STR
		MOV DI, OFFSET HIGHSCORE
		CALL TO_INT
		
		EXIT_READ_HS:
		
		RET
	READ_HS ENDP
	
	TO_INT PROC USES AX BX CX DX SI DI
		MOV COUNTER, 0
		MOV AL, [SI]
		MOV AH, 0
		.WHILE AL != "$"
			SUB AL, 48
			PUSH AX
			INC COUNTER
			INC SI
			MOV AL, [SI]
		.ENDW
		
		MOV BX, 1
		.WHILE COUNTER > 0
			POP AX
			MUL BX
			
			ADD [DI], AX
			
			MOV AX, BX
			MOV BX, 10
			MUL BX
			
			MOV BX, AX
			
			DEC COUNTER
		.ENDW
		RET
	TO_INT ENDP
	
	TO_STR PROC USES AX BX CX DX SI
		MOV COUNTER, 0
		MOV LEN, 0
		MOV BX, 10
		.WHILE AX > 0
			MOV DX, 0
			DIV BX
			PUSH DX
			INC COUNTER
		.ENDW
		
		.WHILE COUNTER > 0
			POP AX
			ADD AX, 48
			MOV [SI], AL
			INC SI
			
			INC LEN
			DEC COUNTER
		.ENDW
		RET
	TO_STR ENDP

GAMEOVER PROC USES AX BX CX DX
		MOV AH, 0
		MOV AL, 6
		INT 10H
		
		MOV BH, 0
		
		MOV AH, 2
		MOV DH, 11
		MOV DL, 35
		INT 10H
		
		MOV DX, OFFSET MOVES_STR
		MOV AH, 9
		INT 21H
		
		MOV AH, 2
		MOV DH, 13
		MOV DL, 36
		INT 10H
		
		MOV DX, OFFSET GAMEOVER_STR
		MOV AH, 9
		INT 21H
		
		MOV CX, 240
		MOV DX, 80
		
		MOV BL, 0
		.WHILE BL < 160
			MOV AH, 0CH
			MOV AL, 15
			INT 10H
			
			INC CX
			
			INC BL
		.ENDW
		
		MOV BL, 0
		.WHILE BL < 35
			MOV AH, 0CH
			MOV AL, 15
			INT 10H
			
			INC DX
			
			INC BL
		.ENDW
		
		MOV BL, 0
		.WHILE BL < 160
			MOV AH, 0CH
			MOV AL, 15
			INT 10H
			
			DEC CX
			
			INC BL
		.ENDW
		
		MOV BL, 0
		.WHILE BL < 35
			MOV AH, 0CH
			MOV AL, 15
			INT 10H
			
			DEC DX
			
			INC BL
		.ENDW
		RET
	GAMEOVER ENDP

END